# PythonLabs
Python labs for RTU MIREA

# lab1.py
Напишите функцию lensort, которая принимает список строк и сортирует его в порядке возрастания их длины. Возвращает отсортированный таким образом список. Исходный список должен остаться неизменным. 

# lab2.py
Напишите функцию lensort, которая принимает список строк и сортирует его в порядке возрастания их длины. Возвращает отсортированный таким образом список. Исходный список должен остаться неизменным. 
 
# lab3.py
Напишите функцию unique, которая удаляет дубликаты из списка и возвращает результат
 
# lab4.py
Напишите функцию, принимающую имя файла с текстом и подсчитывающую частоту встречающихся в нём слов. Каждая линия вывода имеет формат:
«<Слово>: <Сколько раз встречается это слово>» 

# lab5.py
Напишите декоратор, который измеряет время выполнения функции и выводит его в консоль. Проверьте его действие на трёх функциях, принимающих список целых чисел и возвращающих список их квадратов, но выполняющих эту задачу тремя способами: через цикл for, через list comprehension и с использованием встроенной функции map

# lab6.py
Написать key-value хранилище. Данные будут сохраняться в файле storage.data. Добавление новых данных в хранилище и получение текущих значений осуществляется с помощью утилиты командной строки storage.py. Пример работы утилиты:
Сохранение значения value по ключу key_name:
$ storage.py --key key_name --val value

Получение значения по ключу key_name:
$ storage.py --key key_name
Утилита может вызваться со следующими параметрами:
--key <имя ключа>, где <имя ключа> - ключ по которому сохраняются/получаются значения
--val <значение>, где <значение> - сохраняемое значение.
Если при запуске утилиты переданы оба ключа, происходит добавление переданного значения по ключу и сохранение данных в файле. Если передано только имя ключа, происходит чтение файла хранилища и вывод на печать значений, которые были сохранены по данному ключу.  Обратите внимание, что значения по одному ключу не перезаписываются, а добавляются к уже сохраненным. Другими словами - по одному ключу могут храниться несколько значений. При выводе на печать, значения выводятся в порядке их добавления в хранилище. Формат вывода на печать для нескольких значений: 
value_1, value_2

Обратите внимание на пробел после запятой. Если значений по ключу не было найдено, выведите пустую строку или None.

# lab7.py
Реализовать класс вектора на плоскости. Используя перегрузку операторов, реализовать:
- Сложение и вычитание векторов
- Сравнение векторов (равно/не равно)
- Умножение вектора на число
- Скалярное произведение векторов
- Получение длины вектора
- Вывод вектора в консоль при помощи функции print() в формате <x; y>
- Отображение вектора при работе с интерпретатором в формате  <x; y>

# lab8.py
Реализовать иерархию классов для расчёта площади плоских фигур: прямоугольника, треугольника, круга. Базовый класс должен иметь чисто виртуальный метод square(), переопределения которой должны возвращать площадь фигуры. Производные классы фигур должны также иметь член данных для хранения названия фигуры («Circle», «Rectangle», …)

# lab9.py
Реализуйте декоратор, который измеряет время выполнения функции и выводит его в консоль, в виде класса. Реализуйте дополнительный класс-декоратор для вывода полученного времени в формате HTML: <html><body>Время</body></html>. Оба декоратора должны также обеспечивать ведение истории вызовов исходной функции в формате:
<время вызова>: function <имя функции> called with arguments <аргументы>
Используйте данные декораторы вместе на примерах из задачи 5 семинара 1.

# lab10.py
Реализовать класс для логирования сообщений в файл. Сообщения выводятся в формате:
[<статус>] <время вывода>: <сообщение>,
где статус - DEBUG, INFO, WANR, ERROR, CRITICAL.
При этом считается, что в проекте может использоваться только один экземпляр класса-логгера.

